好，下面这一版我会把前面所有共识彻底整合，用稳定、可落盘的工程语言描述一套可直接作为「存档 / 序列化设计说明」的方案。
不再讨论为什么，只说明是什么、怎么存、怎么恢复**。


---

一、系统存档的总体目标

存档系统需要满足以下要求：

1. 支持从任意历史位置继续生成


2. 保留所有已生成内容，不覆盖、不丢失


3. 避免因多次 reroll 产生大量等价分叉


4. 能够完整恢复任意时刻的上下文状态


5. 存档结构清晰，可长期维护和迁移



为此，系统将“上下文变化”和“生成结果变化”在结构上明确区分。


---

二、核心结构划分（存档级别）

存档由三类核心对象组成：

1. 上下文节点（Context Node）


2. 生成记录（Generation Record）


3. 激活指针（Active Pointers）



它们共同构成一份可恢复的存档。


---

三、上下文节点（Context Node）

1. 含义

上下文节点表示一个确定的上下文状态，即：

> 在该节点处，系统认为“世界状态、对话历史和已发生事件”是稳定且被用户确认的。



只有上下文发生变化时，才创建新的上下文节点。


---

2. 上下文节点应存储的内容

每个上下文节点至少包含：

节点唯一标识

父上下文节点标识（根节点除外）

截止该节点的对话历史（可为引用链）

当前完整 state（或 state 快照）

当前 RAG 链表位置或快照索引

小说中已确认的事件历史

默认选中的生成记录 ID


说明：

上下文节点一旦创建，不再被修改

它代表的是“事实状态”，不是候选状态



---

四、生成记录（Generation Record）

1. 含义

生成记录表示：

> 在完全相同的上下文条件下，一次具体的模型生成结果。



生成记录用于承载 reroll 行为，不引入新的上下文节点。


---

2. 生成记录的归属关系

每一条生成记录 必须隶属于某一个上下文节点

同一上下文节点下可以有多条生成记录

生成记录之间没有父子关系



---

3. 生成记录应存储的内容

每条生成记录至少包含：

生成记录唯一标识

所属上下文节点 ID

生成文本内容

生成时间或顺序号

采样参数 / 随机种子（可选）


生成记录本身不修改 state、不修改 RAG、不写入事件。


---

五、reroll 的存档语义

1. reroll 的行为定义

reroll 表示：

> 在当前上下文节点不变的情况下，新增一条生成记录。



reroll 的结果：

不创建新的上下文节点

只在当前上下文节点下追加生成记录



---

2. reroll 在存档中的体现

在存档中：

上下文节点数量不变

该节点下的生成记录列表增长


这实现了：

生成历史的完整保留

上下文结构的压缩



---

六、从生成记录继续生成（进入新上下文）

当用户选择某一条生成记录并继续生成时：

行为流程

1. 读取该生成记录对应的文本


2. 将其作为“已确认输出”


3. 基于该输出更新：

对话历史

state

RAG

小说事件



4. 创建一个新的上下文节点


5. 新节点的父节点为当前上下文节点



存档结果

新上下文节点被写入

该节点记录：它是基于哪一条生成记录继续的（用于回溯）



---

七、回滚与切换的存档处理

1. 回滚上下文

回滚 = 切换当前激活的上下文节点 ID

不删除任何节点或生成记录


2. 切换生成记录

切换生成记录 = 修改当前上下文节点的“默认生成记录指针”

不影响上下文结构



---

八、激活指针（Active Pointers）

为了恢复用户当前状态，存档中需要额外记录：

当前激活的上下文节点 ID

当前激活的生成记录 ID


它们不属于历史事实，仅用于恢复工作状态。


---

九、UI 与存档结构的对应原则

存档中：

不存 UI 状态

UI 在加载存档后，根据：

当前上下文节点

当前生成记录 进行完整重建



结构约束：

历史列表只对应上下文节点

reroll 历史在节点内部展示



---

十、完整存档恢复流程（摘要）

加载存档时：

1. 读取所有上下文节点


2. 读取各节点下的生成记录


3. 定位激活指针


4. 根据激活上下文节点恢复：

对话历史

state

RAG

小说事件



5. 根据激活生成记录恢复当前输出




---

十一、工程总结（可写进设计文档）

上下文节点用于表示“已确认的世界状态”

生成记录用于表示“同一上下文下的多次生成结果”

reroll 只产生生成记录，不产生上下文节点

只有上下文发生变化时，才创建新节点

存档结构为：
上下文树 + 节点内生成历史 + 当前激活指针


这套结构在你当前项目规模下：

可直接实现

可长期扩展

不引入不必要的合并复杂度

且语义清晰、可调试、可迁移


你现在做“存档处理”，按这套定义落盘，是一个工程上稳妥且不会反噬未来的选择。